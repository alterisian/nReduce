.video_wrapper
  #video
    .loading Loading Live Stream...

- if @owner
  %div{:style => 'margin-top: 10px;'}
    = link_to 'Start Recording', '#', :onclick => "initiateArchiveForRecording(); return false;", :class => 'btn btn-success'
    &nbsp;&nbsp;
    = link_to 'Stop Recording', '#', :onclick => "stopRecordingSession(); return false;", :class => 'btn btn-danger'

:plain
  <script type="text/javascript">
  // http://www.tokbox.com/opentok/api/documentation/gettingstarted
  var session;
  var apiKey = '#{Settings.apis.tokbox.key}';
  var sessionId = '#{@tokbox_session_id}';
  var token = '#{@tokbox_token}';    

  // Show loading if stream gets killed
  function streamDestroyed(event) {
    $('.loading').show();
  }

  function exceptionHandler(event) {
    // Retry session connect
    if (event.code === 1006 || event.code === 1008 || event.code === 1014) {
      alert('There was an error connecting. Trying again.');
      session.connect(apiKey, token);
    }
  }

- if @owner
  :plain
    var publisher;
    var archive;

    function sessionConnectedHandler(event) {
      // Put my webcam in a div
      var publishProps = {width:500, height:315};
      publisher = TB.initPublisher(apiKey, 'video', publishProps);
      // Send my stream to the session
      session.publish(publisher);

      // Show video
      $('.loading').remove();

      // Add event listeners
      session.addEventListener("archiveCreated", archiveCreatedHandler);
      session.addEventListener("archiveClosed", archiveClosedHandler);
      session.addEventListener("sessionRecordingStarted", recordingStartedHandler);
      session.addEventListener("sessionRecordingStopped", recordingStoppedHandler);
      session.addEventListener("sessionRecordingInProgress", recordingInProgressHandler);
    }

    function initiateArchiveForRecording(){
      if(archive == undefined || archive == null){
        var d = new Date();
        session.createArchive(#{Settings.apis.tokbox.key}, "perSession", '#{@startup.name} - ' + d.valueOf());
      }else{
        session.closeArchive(archive);
        session.addEventListener("archiveClosed", archiveClosedStartRecordingAgainHandler);
      }
    }

    function archiveClosedStartRecordingAgainHandler(){
      archive = null;
      initiateArchiveForRecording();
    }

    function startRecordingSession(){
      session.startRecording(archive);
    }

    function stopRecordingSession(){
      
      session.stopRecording(archive);
      session.closeArchive(archive);
    }

    function recordingInProgressHandler(event) {
      alert("There is a recording in progress already.");
    }

    function recordingStartedHandler(event) {
      alert("The session is being recorded.");
    }

    function recordingStoppedHandler(event) {
      alert("The session recording has stopped.");
    }

    function archiveCreatedHandler(event) {
      console.log('archive created');
      archive = event.archives[0];
      console.log("Recording archive has been created");
      startRecordingSession();
    }

    function archiveClosedHandler(event){
      console.log("The archive has been successfully closed");
    }

- else
  :plain
    function streamCreated(event) {
      for (var i = 0; i < event.streams.length; i++) {
        var stream = event.streams[i];
        displayStream(stream);
      }
      streams = event.streams;
    }

    function displayStream(stream) {
      var div = document.createElement('div');
      div.setAttribute('id', 'stream' + stream.streamId);
      var streamsContainer = document.getElementById('video');
      streamsContainer.appendChild(div);
      var divProps = {width: 500, height:315};
      subscriber = session.subscribe(stream, 'stream' + stream.streamId, divProps);
      $('.loading').hide();
    }

:plain
  //TB.setLogLevel(TB.DEBUG);
  session = TB.initSession(sessionId);

-# Listen if stream gets created again - to display in case publisher loses connection
- if @owner
  :plain
    session.addEventListener('sessionConnected', sessionConnectedHandler);

- else
  :plain
    session.addEventListener('streamCreated', streamCreated);
    session.addEventListener('streamCreated', streamDestroyed);

:plain
  // Listen for exceptions to try and reconnect
  TB.addEventListener("exception", exceptionHandler);
  
  session.connect(apiKey, token);
  </script>